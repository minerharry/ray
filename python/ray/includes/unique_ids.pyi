
from typing import Generic, TypeVar


T = TypeVar("T")
class BaseID(Generic[T]): #generics are to implement self-typing in C++
    @classmethod
    def from_random(cls: type[T])->T: ...
    @classmethod
    def from_binary(cls: type[T], binary:bytes)->T: ...
    @classmethod
    def from_hex(cls: type[T],hex_str:bytes)->T: ...
    @classmethod
    def nil(cls:type[T])->T: ...
    @classmethod
    def size(cls:type[T])->int: ...

    def __hash__(self:T) -> int: ...
    def is_nil(self:T) -> bool: ...
    def __eq__(self:T, value: object) -> bool: ...
    def __neq__(self:T, value: object) -> bool: ...
    def __bytes__(self:T) -> bytes: ... #I think?

    def binary(self:T)->str: ...
    def hex(self:T)->str: ...


class UniqueID(BaseID[UniqueID]): ...

class JobID(BaseID[JobID]):
    @classmethod
    def from_int(cls:type[JobID], value:int)->JobID: ...

class ActorID(BaseID[ActorID]):
    @classmethod
    def of(cls:type[ActorID], job_id:JobID, parent_task_id:TaskID, parent_task_counter:int): ...

    #in the cpp file, from_random is deleted from ActorID, but the python object does still have it

    def job_id(self:ActorID)->JobID: ...

class TaskID(BaseID[TaskID]):
    #in the cpp file, from_random is deleted from TaskID, but the python object does still have it
    @classmethod
    def for_driver_task(cls:type[TaskID],job_id:JobID)->TaskID: ...
    @classmethod
    def from_random(cls: type[TaskID],job_id:JobID) -> TaskID: ...
    @classmethod
    def for_actor_creation_task(cls:type[TaskID],actor_id:ActorID)->TaskID: ...
    @classmethod
    def for_actor_task(cls:type[TaskID], job_id:JobID, parent_task_id:TaskID, parent_task_counter:int, actor_id:ActorID)->TaskID: ...
    @classmethod
    def for_normal_task(cls:type[TaskID], job_id:JobID, parent_task_id:TaskID, parent_task_counter:int)->TaskID: ...

# class ObjectID(BaseID[ObjectID]):
